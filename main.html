<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>main API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>main</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from __future__ import annotations
import enum
import asyncio
import time
import argparse
import re

BIT_SIZE = 16
MUDA = 432610292342587392

class Waifu:
    &#34;&#34;&#34;
    Represents a waifu from mudae.

    A lot of the attributes will often be null since they either:
        a. Are not applicable
        b. Can&#39;t be read from the waifu message
        c. Need to be fetched with the methods
    Attributes
    ----------
    mudae: discord.User
        The mudae bot that created this waifu.
    user: discord.Client
        The client that&#39;s using this waifu.
    message: discord.Message
        The waifu message the waifu came from.
    owner: discord.Member
        The member whose harem the waifu belongs to.
    creator: discord.Member
        The member that rolled this waifu.
    suitors: list[discord.Member]
        A list of members who wished the waifu.
    name: str
        The name of the waifu.
    series: str
        The series the waifu belongs to.
    kakera: int
        The kakera value of the waifu.
    key: int
        The key level of the waifu.
    claims: int
        The claims rank of the waifu.
    likes: int
        The likes rank of the waifu
    type: Waifu.Type
        The type of the waifu.
    image: str
        URL of the image, that the waifu message had, when the object was created.
    image_count: int
        How many images the waifu has available in total.
    image_index: int
        Image index of the image attribute with respect to the avaliable images.
    image_extra: int
        How many extra images have been added to the waifu.
    is_claimed: bool
        If the waifu has been claimed yet.
    is_roll: bool
        If the waifu is a roll.
    is_girl: bool
        If the waifu is female or both female and male.
    Methods
    -------
    async fetch_extra()
        Fills the suitor and creator attributes.
    async await_claim()
        Waits for a member to claim this waifu, then returns with that member.
    &#34;&#34;&#34;

    class Type(enum.Enum):
        &#34;&#34;&#34;
        Represents the different types of waifus.
        Enums
        -----
        roll: 0
            The waifu was rolled e.g. created with $w.
        info: 1
            The waifu came from the info command e.g. created with $im.
        &#34;&#34;&#34;

        roll = enum.auto()
        info = enum.auto()

    def __init__(self, mudae, user, message):
        self.mudae = mudae
        self.message = message
        self.user = user
        self.suitors = []
        self.name = None
        self.series = None
        self.kakera = None
        self.key = None
        self.claims = None
        self.likes = None
        self.owner = None
        self.image = None
        self.creator = None
        self.image_count = None
        self.image_index = None
        self.image_extra = None
        self.type = None
        # self.ka_react = None
        # self.is_claimed, self.is_girl and self.is_roll won&#39;t be initialized to avoid them being accidentally interpreted as False

        # Message is missing parts to match against and can&#39;t be a match
        if message.author != self.mudae or not len(message.embeds) == 1 or message.embeds[0].image.url == message.embeds[0].Empty:
            raise TypeError(&#34;Message passed to the Waifu constructor it not a valid mudae message&#34;)

        embed = message.embeds[0]
        desc = embed.description + &#34;\n&#34;
        self.name = embed.author.name
        self.image = embed.image.url

        def match_n_replace(pattern: str, string: str):
            match = re.search(pattern, desc, re.DOTALL)
            if match:
                string = string.replace(match.group(0), &#34;&#34;, 1)
                match = match.group(1).replace(&#34;\n&#34;, &#34; &#34;).strip()
            return match, string

        # Extract series
        # language=RegExp
        self.series, desc = match_n_replace(r&#34;^([^&lt;\n]*)\n?&#34;, desc)

        # Extract kakera
        # language=RegExp
        self.kakera, desc = match_n_replace(r&#34;\*\*(\d+?)\*\*&lt;.*&gt;\n&#34;, desc)
        self.kakera = int(self.kakera)

        if self.series:
            self.type = self.Type.roll
            self.is_roll = True

        # Try to match to infos:
        match = re.search(r&#34;&#34;&#34;^(.*)                #From the start of the string, series captured
                               \ &lt;:(.+?):\d+?&gt;.*?     #First emoji, gender captured
                               \*\*(\d*)              #Kakera Value captured
                               [^(]*                  #Consume until &#34;claim&#34;, but stop if hit bracket, to allow key to be captured
                               (?:\((\d*)\))?.*       #Optionally capture key value
                               Claims:\ \#(\d*).*?    #Claims captured
                               Likes:\ \#(\d*)        #Likes captured
                               &#34;&#34;&#34;, desc, re.DOTALL | re.VERBOSE)
        if match:
            self.series = match.group(1).replace(&#34;\n&#34;, &#34; &#34;)
            if match.group(2) == &#34;female&#34;:
                self.is_girl = True
            else:
                self.is_girl = False
            self.kakera = int(match.group(3))
            if match.group(4):
                self.key = int(match.group(4))
            else:
                self.key = 0
            self.claims = int(match.group(5))
            self.likes = int(match.group(6))
            self.type = self.Type.info
            self.is_roll = False

        # Did it match?
        if not self.series:
            raise TypeError(&#34;Message passed to the Waifu constructor it not a valid mudae message&#34;)

        # Try to match footer:
        if not embed.footer.text:
            self.is_claimed = False
        else:
            match = re.search(r&#34;&#34;&#34;(?:Belongs\ to\ (.+?))? #Optionally capture owner
                                   (?:\ ~~\ )?               #Optionally match separator
                                   (?:                       #----&gt; Optionally capture image data
                                       (\d+?)                    #Capture first index
                                       \ /\ (\d+)                #Capture second index
                                       (?:\ \[(\d+?)\])?         #Optionally capture third index
                                   )?$                       #&lt;----- end of string
                                   &#34;&#34;&#34;, embed.footer.text, re.VERBOSE | re.DOTALL)
            if match.group(1):
                self.owner = message.guild.get_member_named(match.group(1))
                self.is_claimed = True
            else:
                self.is_claimed = False
            if match.group(2):
                self.image_index = int(match.group(2))
            if match.group(3):
                self.image_count = int(match.group(3))
            if match.group(4):
                self.image_extra = int(match.group(4))
            else:
                self.image_extra = 0

    async def fetch_extra(self):
        &#34;&#34;&#34;
        Fills the suitor and creator attributes.
        The suitor and creator attributes are by default empty and null respectively. To get the real values, this method must be called.
        The method will only work for waifus of type roll and only if the waifu was just rolled.
        &#34;&#34;&#34;

        state = 0
        async for message in self.message.channel.history(limit=10):
            if state == 0:
                if message.id == self.message.id:
                    state = 1
            elif state == 1:
                state += 1
                if message.author != self.mudae:
                    self.creator = message.author
                    break
                elif &#34;wished&#34; in message.content.lower():
                    self.suitors = message.mentions
            elif state == 5:
                break
            else:
                state += 1
                if message.author != self.mudae:
                    self.creator = message.author
                    break

        # await asyncio.sleep(1)
        # UNTESTED -------------------&gt;
        &#34;&#34;&#34;
        self.message = await self.message.channel.fetch_message(self.message_id)
        if self.is_claimed and self.is_roll:
            for react in self.message.reactions:
                name = react.emoji.name
                if &#34;kakera&#34; in name:
                    name = name.replace(&#34;kakera&#34;, &#34;&#34;)
                    if name == &#34;&#34;:
                        name = &#34;K&#34;
                    self.ka_react = name
                    break
        &#34;&#34;&#34;

    async def await_claim(self):
        &#34;&#34;&#34;
        Waits for a member to claim this waifu, then returns with that member.
        If the waifu has already been claimed, the owner is returned immediately.
        If the waifu doesn&#39;t have an owner, the function will wait for up to 60s for someone to claim.
        Returns none if after 60s no one has claimed.
        Returns
        -------
        Waifu
            The waifu has an owner or one is found.
        None
            No owner could be found, the waifu wasn&#39;t claimed within 60s.
        &#34;&#34;&#34;

        if self.is_claimed:
            return self.owner

        def check(message):
            return message.author == self.mudae and self.name in message.content and &#34;are now married&#34; in message.content.lower()

        try:
            message = await self.user.wait_for(&#34;message&#34;, timeout=60, check=check)
            user_name = message.content.split(&#34;**&#34;)[1]
            self.owner = message.guild.get_member_named(user_name)
            self.is_claimed = True
            return self.owner

        except asyncio.TimeoutError:
            return None


    def __str__(self):
        return self.name


class Mudae:
    &#34;&#34;&#34;
    Represents a mudae bot. Primarily used as a factory for Waifu objects.
    Before doing anything with this class, make sure you&#39;ve configured your mudae bot properly.
    Kakera value must be visible on rolls, for this class to be able to read the messages from mudae.
    If you want to check for claim or roll resets, you must provide the optional timing parameter
    ----------
    mudae: discord.User
        The mudea bot.
    user: discord.Client
        The client that&#39;s using this class.
    has_timing: bool
        If the module was created
    Methods
    -------
    waifu_from(message)
        Returns a waifu from a waifu message.
    is_wish(message, wishes, check_name, check_series)
        Checks if the waifu from a waifu message is part of a list of wishes.
    until_roll(in_seconds)
        Returns how much time there&#39;s left until the next roll reset.
    until_claim(in_seconds)
        Returns how much time there&#39;s left until the next claim reset.
    async wait_roll()
         Pauses until next roll reset.
    async wait_claim()
         Pauses until next claim reset.
    &#34;&#34;&#34;

    def __init__(self, user, timing: tuple[int,...]=None):
        &#34;&#34;&#34;
        Parameters
        ----------
        user: discord.Client
            The client that&#39;s using this class.
        timing: int
            Value encoded with information on claim and roll resets. Use the get_timing method to create one.
        &#34;&#34;&#34;

        self.user = user
        self.mudae = user.get_user(MUDA)

        if timing:
            # timings = _split_timing(timing)
            timings = timing
            self._roll_mod = timings[0]
            self._claim_mod = timings[1]
            self._roll_rem = timings[2]
            self._claim_rem = timings[3]
            self.has_timing = True
        else:
            self.has_timing = False

    def waifu_from(self, message):
        &#34;&#34;&#34;
        Returns a waifu from a message.
        Currently two types of messages are supported, rolls and infoes. Rolls are usually created with the $w command, and infoes with the $im command.
        If the message supplied is none of the two valid types of messages, or is not valid for another reason, none is returned.
        Parameters
        ----------
        message: discord.Message
            A discord message from mudae with a waifu (a waifu message).
        Returns
        -------
        Waifu
            A waifu created from the message.
        None
            The message isn&#39;t valid.
        &#34;&#34;&#34;

        try:
            return Waifu(self.mudae, self.user, message)
        except TypeError:
            return None

    def from_wish(self, message, wishes: list[str], check_name: bool=True, check_series: bool=False):
        &#34;&#34;&#34;
        Checks if the waifu from a waifu message is part of a list of wishes.
        If both check_name and check_series are true, the wishes will be checked against both name and series.
        If both are false, the function will always return false.
        Parameters
        ----------
        message: discord.Message
            A discord waifu message.
        wishes: list
            A list of strings, where each string is a wish.
        check_name: bool
            Whether the wishes are wishes for specific waifus.
        check_series: bool
            Whether the wishes are wishes for specific series.
        Returns
        -------
        bool
            Whether the waifu was wished.
        &#34;&#34;&#34;
        waifu = self.waifu_from(message)
        wishes = map(lambda wish: wish.lower(), wishes)
        if not waifu:
            return None
        if check_name and waifu.name.lower() in wishes:
            return waifu
        if check_series and waifu.series.lower() in wishes:
            return waifu
        return False

    def until_roll(self, in_seconds: bool=False):
        &#34;&#34;&#34;
        Returns how much time there&#39;s left until the next roll reset.
        Parameters
        ----------
        in_seconds: bool
            Whether the time returned should be in seconds or minutes.
        Returns
        -------
        int
            The time left until next roll reset.
        &#34;&#34;&#34;

        if not self.has_timing:
            raise TypeError(&#34;Missing cooldown data&#34;)
        left = self._roll_rem - (int(time.time()) % self._roll_mod)
        if left &lt; 0:
            left += self._roll_mod
        if not in_seconds:
            left = int(left / 60)
        return left

    def until_claim(self, in_seconds: bool=False):
        &#34;&#34;&#34;
        Returns how much time there&#39;s left until the next claim reset.
        Parameters
        ----------
        in_seconds: bool
            Whether the time returned should be in seconds or minutes.
        Returns
        -------
        int
            The time left until next claim reset.
        &#34;&#34;&#34;

        if not self.has_timing:
            raise TypeError(&#34;Missing cooldown data&#34;)
        left = self._claim_rem - (int(time.time()) % self._claim_mod)
        if left &lt; 0:
            left += self._claim_mod
        if not in_seconds:
            left = int(left / 60)
        return left

    async def wait_roll(self):
        &#34;&#34;&#34;
        Pauses until next roll reset.
        &#34;&#34;&#34;

        await asyncio.sleep(5)
        await asyncio.sleep(self.until_roll(True))

    async def wait_claim(self):
        &#34;&#34;&#34;
        Pauses until next claim reset.
        &#34;&#34;&#34;

        await asyncio.sleep(5)
        await asyncio.sleep(self.until_claim(True))


def get_timing(roll_mod: int, claim_mod: int, roll_rem: int, claim_rem: int, in_seconds=False) -&gt; tuple[int,...]:
    &#34;&#34;&#34;
     A static method that returns an integer from the supplied parameters.
     The integer may be provided to the Mudae constructor to enable roll and claim cool-down functionality
     Parameters
     ----------
     roll_mod: int
         The time period, between roll resets. The default mudae value for this is 60 min.
     claim_mod: int
         The time period, between claim resets. The default mudae value for this is 120 min.
     roll_rem: int
         The time period, from now until the next roll reset.
     claim_rem: int
         The time period, from now until the next claim reset.
     in_seconds: bool
         If the time periods are given as seconds or minutes.
     &#34;&#34;&#34;

    if not in_seconds:
        roll_mod *= 60
        claim_mod *= 60
        roll_rem *= 60
        claim_rem *= 60

    timings = 0
    roll_rem = (int(time.time()) + roll_rem) % roll_mod
    claim_rem = (int(time.time()) + claim_rem) % claim_mod
    all_vals = (roll_mod, claim_mod, roll_rem, claim_rem)
    #for value in reversed(all_vals):
    #    timings &lt;&lt;= BIT_SIZE
    #    timings += value
    #return timings
    return all_vals


def _split_timing(timing: int) -&gt; tuple[int,...]:
    mask = (1 &lt;&lt; BIT_SIZE + 1) - 1
    nums = []
    for _ in range(4):
        nums.append(timing &amp; mask)
        timing &gt;&gt;= BIT_SIZE
    return tuple(nums)


if __name__ == &#39;__main__&#39;:
    parser = argparse.ArgumentParser()
    parser.add_argument(&#34;--rr&#34;, type=int, help=&#34;Time until next roll reset&#34;, required=True)
    parser.add_argument(&#34;--cr&#34;, type=int, help=&#34;Time until next claim reset&#34;, required=True)
    parser.add_argument(&#34;--rm&#34;, type=int, help=&#34;Time period between each roll reset (Defaults to 60)&#34;, default=60)
    parser.add_argument(&#34;--cm&#34;, type=int, help=&#34;Time period between each claim reset (Defaults to 180)&#34;, default=180)
    args = parser.parse_args()
    print(get_timing(args.rm, args.cm, args.rr, args.cr))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="main.get_timing"><code class="name flex">
<span>def <span class="ident">get_timing</span></span>(<span>roll_mod: int, claim_mod: int, roll_rem: int, claim_rem: int, in_seconds=False) ‑> tuple[int, ...]</span>
</code></dt>
<dd>
<div class="desc"><p>A static method that returns an integer from the supplied parameters.
The integer may be provided to the Mudae constructor to enable roll and claim cool-down functionality
Parameters</p>
<hr>
<dl>
<dt><strong><code>roll_mod</code></strong> :&ensp;<code>int</code></dt>
<dd>The time period, between roll resets. The default mudae value for this is 60 min.</dd>
<dt><strong><code>claim_mod</code></strong> :&ensp;<code>int</code></dt>
<dd>The time period, between claim resets. The default mudae value for this is 120 min.</dd>
<dt><strong><code>roll_rem</code></strong> :&ensp;<code>int</code></dt>
<dd>The time period, from now until the next roll reset.</dd>
<dt><strong><code>claim_rem</code></strong> :&ensp;<code>int</code></dt>
<dd>The time period, from now until the next claim reset.</dd>
<dt><strong><code>in_seconds</code></strong> :&ensp;<code>bool</code></dt>
<dd>If the time periods are given as seconds or minutes.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_timing(roll_mod: int, claim_mod: int, roll_rem: int, claim_rem: int, in_seconds=False) -&gt; tuple[int,...]:
    &#34;&#34;&#34;
     A static method that returns an integer from the supplied parameters.
     The integer may be provided to the Mudae constructor to enable roll and claim cool-down functionality
     Parameters
     ----------
     roll_mod: int
         The time period, between roll resets. The default mudae value for this is 60 min.
     claim_mod: int
         The time period, between claim resets. The default mudae value for this is 120 min.
     roll_rem: int
         The time period, from now until the next roll reset.
     claim_rem: int
         The time period, from now until the next claim reset.
     in_seconds: bool
         If the time periods are given as seconds or minutes.
     &#34;&#34;&#34;

    if not in_seconds:
        roll_mod *= 60
        claim_mod *= 60
        roll_rem *= 60
        claim_rem *= 60

    timings = 0
    roll_rem = (int(time.time()) + roll_rem) % roll_mod
    claim_rem = (int(time.time()) + claim_rem) % claim_mod
    all_vals = (roll_mod, claim_mod, roll_rem, claim_rem)
    #for value in reversed(all_vals):
    #    timings &lt;&lt;= BIT_SIZE
    #    timings += value
    #return timings
    return all_vals</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="main.Mudae"><code class="flex name class">
<span>class <span class="ident">Mudae</span></span>
<span>(</span><span>user, timing: tuple[int, ...] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents a mudae bot. Primarily used as a factory for Waifu objects.
Before doing anything with this class, make sure you've configured your mudae bot properly.
Kakera value must be visible on rolls, for this class to be able to read the messages from mudae.
If you want to check for claim or roll resets, you must provide the optional timing parameter</p>
<hr>
<p>mudae: discord.User
The mudea bot.
user: discord.Client
The client that's using this class.
has_timing: bool
If the module was created
Methods</p>
<hr>
<p>waifu_from(message)
Returns a waifu from a waifu message.
is_wish(message, wishes, check_name, check_series)
Checks if the waifu from a waifu message is part of a list of wishes.
until_roll(in_seconds)
Returns how much time there's left until the next roll reset.
until_claim(in_seconds)
Returns how much time there's left until the next claim reset.
async wait_roll()
Pauses until next roll reset.
async wait_claim()
Pauses until next claim reset.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>user</code></strong> :&ensp;<code>discord.Client</code></dt>
<dd>The client that's using this class.</dd>
<dt><strong><code>timing</code></strong> :&ensp;<code>int</code></dt>
<dd>Value encoded with information on claim and roll resets. Use the get_timing method to create one.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Mudae:
    &#34;&#34;&#34;
    Represents a mudae bot. Primarily used as a factory for Waifu objects.
    Before doing anything with this class, make sure you&#39;ve configured your mudae bot properly.
    Kakera value must be visible on rolls, for this class to be able to read the messages from mudae.
    If you want to check for claim or roll resets, you must provide the optional timing parameter
    ----------
    mudae: discord.User
        The mudea bot.
    user: discord.Client
        The client that&#39;s using this class.
    has_timing: bool
        If the module was created
    Methods
    -------
    waifu_from(message)
        Returns a waifu from a waifu message.
    is_wish(message, wishes, check_name, check_series)
        Checks if the waifu from a waifu message is part of a list of wishes.
    until_roll(in_seconds)
        Returns how much time there&#39;s left until the next roll reset.
    until_claim(in_seconds)
        Returns how much time there&#39;s left until the next claim reset.
    async wait_roll()
         Pauses until next roll reset.
    async wait_claim()
         Pauses until next claim reset.
    &#34;&#34;&#34;

    def __init__(self, user, timing: tuple[int,...]=None):
        &#34;&#34;&#34;
        Parameters
        ----------
        user: discord.Client
            The client that&#39;s using this class.
        timing: int
            Value encoded with information on claim and roll resets. Use the get_timing method to create one.
        &#34;&#34;&#34;

        self.user = user
        self.mudae = user.get_user(MUDA)

        if timing:
            # timings = _split_timing(timing)
            timings = timing
            self._roll_mod = timings[0]
            self._claim_mod = timings[1]
            self._roll_rem = timings[2]
            self._claim_rem = timings[3]
            self.has_timing = True
        else:
            self.has_timing = False

    def waifu_from(self, message):
        &#34;&#34;&#34;
        Returns a waifu from a message.
        Currently two types of messages are supported, rolls and infoes. Rolls are usually created with the $w command, and infoes with the $im command.
        If the message supplied is none of the two valid types of messages, or is not valid for another reason, none is returned.
        Parameters
        ----------
        message: discord.Message
            A discord message from mudae with a waifu (a waifu message).
        Returns
        -------
        Waifu
            A waifu created from the message.
        None
            The message isn&#39;t valid.
        &#34;&#34;&#34;

        try:
            return Waifu(self.mudae, self.user, message)
        except TypeError:
            return None

    def from_wish(self, message, wishes: list[str], check_name: bool=True, check_series: bool=False):
        &#34;&#34;&#34;
        Checks if the waifu from a waifu message is part of a list of wishes.
        If both check_name and check_series are true, the wishes will be checked against both name and series.
        If both are false, the function will always return false.
        Parameters
        ----------
        message: discord.Message
            A discord waifu message.
        wishes: list
            A list of strings, where each string is a wish.
        check_name: bool
            Whether the wishes are wishes for specific waifus.
        check_series: bool
            Whether the wishes are wishes for specific series.
        Returns
        -------
        bool
            Whether the waifu was wished.
        &#34;&#34;&#34;
        waifu = self.waifu_from(message)
        wishes = map(lambda wish: wish.lower(), wishes)
        if not waifu:
            return None
        if check_name and waifu.name.lower() in wishes:
            return waifu
        if check_series and waifu.series.lower() in wishes:
            return waifu
        return False

    def until_roll(self, in_seconds: bool=False):
        &#34;&#34;&#34;
        Returns how much time there&#39;s left until the next roll reset.
        Parameters
        ----------
        in_seconds: bool
            Whether the time returned should be in seconds or minutes.
        Returns
        -------
        int
            The time left until next roll reset.
        &#34;&#34;&#34;

        if not self.has_timing:
            raise TypeError(&#34;Missing cooldown data&#34;)
        left = self._roll_rem - (int(time.time()) % self._roll_mod)
        if left &lt; 0:
            left += self._roll_mod
        if not in_seconds:
            left = int(left / 60)
        return left

    def until_claim(self, in_seconds: bool=False):
        &#34;&#34;&#34;
        Returns how much time there&#39;s left until the next claim reset.
        Parameters
        ----------
        in_seconds: bool
            Whether the time returned should be in seconds or minutes.
        Returns
        -------
        int
            The time left until next claim reset.
        &#34;&#34;&#34;

        if not self.has_timing:
            raise TypeError(&#34;Missing cooldown data&#34;)
        left = self._claim_rem - (int(time.time()) % self._claim_mod)
        if left &lt; 0:
            left += self._claim_mod
        if not in_seconds:
            left = int(left / 60)
        return left

    async def wait_roll(self):
        &#34;&#34;&#34;
        Pauses until next roll reset.
        &#34;&#34;&#34;

        await asyncio.sleep(5)
        await asyncio.sleep(self.until_roll(True))

    async def wait_claim(self):
        &#34;&#34;&#34;
        Pauses until next claim reset.
        &#34;&#34;&#34;

        await asyncio.sleep(5)
        await asyncio.sleep(self.until_claim(True))</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="main.Mudae.from_wish"><code class="name flex">
<span>def <span class="ident">from_wish</span></span>(<span>self, message, wishes: list[str], check_name: bool = True, check_series: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if the waifu from a waifu message is part of a list of wishes.
If both check_name and check_series are true, the wishes will be checked against both name and series.
If both are false, the function will always return false.
Parameters</p>
<hr>
<dl>
<dt><strong><code>message</code></strong> :&ensp;<code>discord.Message</code></dt>
<dd>A discord waifu message.</dd>
<dt><strong><code>wishes</code></strong> :&ensp;<code>list</code></dt>
<dd>A list of strings, where each string is a wish.</dd>
<dt><strong><code>check_name</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether the wishes are wishes for specific waifus.</dd>
<dt><strong><code>check_series</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether the wishes are wishes for specific series.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>Whether the waifu was wished.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_wish(self, message, wishes: list[str], check_name: bool=True, check_series: bool=False):
    &#34;&#34;&#34;
    Checks if the waifu from a waifu message is part of a list of wishes.
    If both check_name and check_series are true, the wishes will be checked against both name and series.
    If both are false, the function will always return false.
    Parameters
    ----------
    message: discord.Message
        A discord waifu message.
    wishes: list
        A list of strings, where each string is a wish.
    check_name: bool
        Whether the wishes are wishes for specific waifus.
    check_series: bool
        Whether the wishes are wishes for specific series.
    Returns
    -------
    bool
        Whether the waifu was wished.
    &#34;&#34;&#34;
    waifu = self.waifu_from(message)
    wishes = map(lambda wish: wish.lower(), wishes)
    if not waifu:
        return None
    if check_name and waifu.name.lower() in wishes:
        return waifu
    if check_series and waifu.series.lower() in wishes:
        return waifu
    return False</code></pre>
</details>
</dd>
<dt id="main.Mudae.until_claim"><code class="name flex">
<span>def <span class="ident">until_claim</span></span>(<span>self, in_seconds: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns how much time there's left until the next claim reset.
Parameters</p>
<hr>
<dl>
<dt><strong><code>in_seconds</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether the time returned should be in seconds or minutes.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The time left until next claim reset.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def until_claim(self, in_seconds: bool=False):
    &#34;&#34;&#34;
    Returns how much time there&#39;s left until the next claim reset.
    Parameters
    ----------
    in_seconds: bool
        Whether the time returned should be in seconds or minutes.
    Returns
    -------
    int
        The time left until next claim reset.
    &#34;&#34;&#34;

    if not self.has_timing:
        raise TypeError(&#34;Missing cooldown data&#34;)
    left = self._claim_rem - (int(time.time()) % self._claim_mod)
    if left &lt; 0:
        left += self._claim_mod
    if not in_seconds:
        left = int(left / 60)
    return left</code></pre>
</details>
</dd>
<dt id="main.Mudae.until_roll"><code class="name flex">
<span>def <span class="ident">until_roll</span></span>(<span>self, in_seconds: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns how much time there's left until the next roll reset.
Parameters</p>
<hr>
<dl>
<dt><strong><code>in_seconds</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether the time returned should be in seconds or minutes.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The time left until next roll reset.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def until_roll(self, in_seconds: bool=False):
    &#34;&#34;&#34;
    Returns how much time there&#39;s left until the next roll reset.
    Parameters
    ----------
    in_seconds: bool
        Whether the time returned should be in seconds or minutes.
    Returns
    -------
    int
        The time left until next roll reset.
    &#34;&#34;&#34;

    if not self.has_timing:
        raise TypeError(&#34;Missing cooldown data&#34;)
    left = self._roll_rem - (int(time.time()) % self._roll_mod)
    if left &lt; 0:
        left += self._roll_mod
    if not in_seconds:
        left = int(left / 60)
    return left</code></pre>
</details>
</dd>
<dt id="main.Mudae.waifu_from"><code class="name flex">
<span>def <span class="ident">waifu_from</span></span>(<span>self, message)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a waifu from a message.
Currently two types of messages are supported, rolls and infoes. Rolls are usually created with the $w command, and infoes with the $im command.
If the message supplied is none of the two valid types of messages, or is not valid for another reason, none is returned.
Parameters</p>
<hr>
<dl>
<dt><strong><code>message</code></strong> :&ensp;<code>discord.Message</code></dt>
<dd>A discord message from mudae with a waifu (a waifu message).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="main.Waifu" href="#main.Waifu">Waifu</a></code></dt>
<dd>A waifu created from the message.</dd>
<dt><code>None</code></dt>
<dd>The message isn't valid.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def waifu_from(self, message):
    &#34;&#34;&#34;
    Returns a waifu from a message.
    Currently two types of messages are supported, rolls and infoes. Rolls are usually created with the $w command, and infoes with the $im command.
    If the message supplied is none of the two valid types of messages, or is not valid for another reason, none is returned.
    Parameters
    ----------
    message: discord.Message
        A discord message from mudae with a waifu (a waifu message).
    Returns
    -------
    Waifu
        A waifu created from the message.
    None
        The message isn&#39;t valid.
    &#34;&#34;&#34;

    try:
        return Waifu(self.mudae, self.user, message)
    except TypeError:
        return None</code></pre>
</details>
</dd>
<dt id="main.Mudae.wait_claim"><code class="name flex">
<span>async def <span class="ident">wait_claim</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Pauses until next claim reset.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def wait_claim(self):
    &#34;&#34;&#34;
    Pauses until next claim reset.
    &#34;&#34;&#34;

    await asyncio.sleep(5)
    await asyncio.sleep(self.until_claim(True))</code></pre>
</details>
</dd>
<dt id="main.Mudae.wait_roll"><code class="name flex">
<span>async def <span class="ident">wait_roll</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Pauses until next roll reset.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def wait_roll(self):
    &#34;&#34;&#34;
    Pauses until next roll reset.
    &#34;&#34;&#34;

    await asyncio.sleep(5)
    await asyncio.sleep(self.until_roll(True))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="main.Waifu"><code class="flex name class">
<span>class <span class="ident">Waifu</span></span>
<span>(</span><span>mudae, user, message)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents a waifu from mudae.</p>
<p>A lot of the attributes will often be null since they either:
a. Are not applicable
b. Can't be read from the waifu message
c. Need to be fetched with the methods
Attributes</p>
<hr>
<dl>
<dt><strong><code>mudae</code></strong> :&ensp;<code>discord.User</code></dt>
<dd>The mudae bot that created this waifu.</dd>
<dt><strong><code>user</code></strong> :&ensp;<code>discord.Client</code></dt>
<dd>The client that's using this waifu.</dd>
<dt><strong><code>message</code></strong> :&ensp;<code>discord.Message</code></dt>
<dd>The waifu message the waifu came from.</dd>
<dt><strong><code>owner</code></strong> :&ensp;<code>discord.Member</code></dt>
<dd>The member whose harem the waifu belongs to.</dd>
<dt><strong><code>creator</code></strong> :&ensp;<code>discord.Member</code></dt>
<dd>The member that rolled this waifu.</dd>
<dt><strong><code>suitors</code></strong> :&ensp;<code>list[discord.Member]</code></dt>
<dd>A list of members who wished the waifu.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the waifu.</dd>
<dt><strong><code>series</code></strong> :&ensp;<code>str</code></dt>
<dd>The series the waifu belongs to.</dd>
<dt><strong><code>kakera</code></strong> :&ensp;<code>int</code></dt>
<dd>The kakera value of the waifu.</dd>
<dt><strong><code>key</code></strong> :&ensp;<code>int</code></dt>
<dd>The key level of the waifu.</dd>
<dt><strong><code>claims</code></strong> :&ensp;<code>int</code></dt>
<dd>The claims rank of the waifu.</dd>
<dt><strong><code>likes</code></strong> :&ensp;<code>int</code></dt>
<dd>The likes rank of the waifu</dd>
<dt><strong><code>type</code></strong> :&ensp;<code><a title="main.Waifu.Type" href="#main.Waifu.Type">Waifu.Type</a></code></dt>
<dd>The type of the waifu.</dd>
<dt><strong><code>image</code></strong> :&ensp;<code>str</code></dt>
<dd>URL of the image, that the waifu message had, when the object was created.</dd>
<dt><strong><code>image_count</code></strong> :&ensp;<code>int</code></dt>
<dd>How many images the waifu has available in total.</dd>
<dt><strong><code>image_index</code></strong> :&ensp;<code>int</code></dt>
<dd>Image index of the image attribute with respect to the avaliable images.</dd>
<dt><strong><code>image_extra</code></strong> :&ensp;<code>int</code></dt>
<dd>How many extra images have been added to the waifu.</dd>
<dt><strong><code>is_claimed</code></strong> :&ensp;<code>bool</code></dt>
<dd>If the waifu has been claimed yet.</dd>
<dt><strong><code>is_roll</code></strong> :&ensp;<code>bool</code></dt>
<dd>If the waifu is a roll.</dd>
<dt><strong><code>is_girl</code></strong> :&ensp;<code>bool</code></dt>
<dd>If the waifu is female or both female and male.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>async fetch_extra()
Fills the suitor and creator attributes.
async await_claim()
Waits for a member to claim this waifu, then returns with that member.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Waifu:
    &#34;&#34;&#34;
    Represents a waifu from mudae.

    A lot of the attributes will often be null since they either:
        a. Are not applicable
        b. Can&#39;t be read from the waifu message
        c. Need to be fetched with the methods
    Attributes
    ----------
    mudae: discord.User
        The mudae bot that created this waifu.
    user: discord.Client
        The client that&#39;s using this waifu.
    message: discord.Message
        The waifu message the waifu came from.
    owner: discord.Member
        The member whose harem the waifu belongs to.
    creator: discord.Member
        The member that rolled this waifu.
    suitors: list[discord.Member]
        A list of members who wished the waifu.
    name: str
        The name of the waifu.
    series: str
        The series the waifu belongs to.
    kakera: int
        The kakera value of the waifu.
    key: int
        The key level of the waifu.
    claims: int
        The claims rank of the waifu.
    likes: int
        The likes rank of the waifu
    type: Waifu.Type
        The type of the waifu.
    image: str
        URL of the image, that the waifu message had, when the object was created.
    image_count: int
        How many images the waifu has available in total.
    image_index: int
        Image index of the image attribute with respect to the avaliable images.
    image_extra: int
        How many extra images have been added to the waifu.
    is_claimed: bool
        If the waifu has been claimed yet.
    is_roll: bool
        If the waifu is a roll.
    is_girl: bool
        If the waifu is female or both female and male.
    Methods
    -------
    async fetch_extra()
        Fills the suitor and creator attributes.
    async await_claim()
        Waits for a member to claim this waifu, then returns with that member.
    &#34;&#34;&#34;

    class Type(enum.Enum):
        &#34;&#34;&#34;
        Represents the different types of waifus.
        Enums
        -----
        roll: 0
            The waifu was rolled e.g. created with $w.
        info: 1
            The waifu came from the info command e.g. created with $im.
        &#34;&#34;&#34;

        roll = enum.auto()
        info = enum.auto()

    def __init__(self, mudae, user, message):
        self.mudae = mudae
        self.message = message
        self.user = user
        self.suitors = []
        self.name = None
        self.series = None
        self.kakera = None
        self.key = None
        self.claims = None
        self.likes = None
        self.owner = None
        self.image = None
        self.creator = None
        self.image_count = None
        self.image_index = None
        self.image_extra = None
        self.type = None
        # self.ka_react = None
        # self.is_claimed, self.is_girl and self.is_roll won&#39;t be initialized to avoid them being accidentally interpreted as False

        # Message is missing parts to match against and can&#39;t be a match
        if message.author != self.mudae or not len(message.embeds) == 1 or message.embeds[0].image.url == message.embeds[0].Empty:
            raise TypeError(&#34;Message passed to the Waifu constructor it not a valid mudae message&#34;)

        embed = message.embeds[0]
        desc = embed.description + &#34;\n&#34;
        self.name = embed.author.name
        self.image = embed.image.url

        def match_n_replace(pattern: str, string: str):
            match = re.search(pattern, desc, re.DOTALL)
            if match:
                string = string.replace(match.group(0), &#34;&#34;, 1)
                match = match.group(1).replace(&#34;\n&#34;, &#34; &#34;).strip()
            return match, string

        # Extract series
        # language=RegExp
        self.series, desc = match_n_replace(r&#34;^([^&lt;\n]*)\n?&#34;, desc)

        # Extract kakera
        # language=RegExp
        self.kakera, desc = match_n_replace(r&#34;\*\*(\d+?)\*\*&lt;.*&gt;\n&#34;, desc)
        self.kakera = int(self.kakera)

        if self.series:
            self.type = self.Type.roll
            self.is_roll = True

        # Try to match to infos:
        match = re.search(r&#34;&#34;&#34;^(.*)                #From the start of the string, series captured
                               \ &lt;:(.+?):\d+?&gt;.*?     #First emoji, gender captured
                               \*\*(\d*)              #Kakera Value captured
                               [^(]*                  #Consume until &#34;claim&#34;, but stop if hit bracket, to allow key to be captured
                               (?:\((\d*)\))?.*       #Optionally capture key value
                               Claims:\ \#(\d*).*?    #Claims captured
                               Likes:\ \#(\d*)        #Likes captured
                               &#34;&#34;&#34;, desc, re.DOTALL | re.VERBOSE)
        if match:
            self.series = match.group(1).replace(&#34;\n&#34;, &#34; &#34;)
            if match.group(2) == &#34;female&#34;:
                self.is_girl = True
            else:
                self.is_girl = False
            self.kakera = int(match.group(3))
            if match.group(4):
                self.key = int(match.group(4))
            else:
                self.key = 0
            self.claims = int(match.group(5))
            self.likes = int(match.group(6))
            self.type = self.Type.info
            self.is_roll = False

        # Did it match?
        if not self.series:
            raise TypeError(&#34;Message passed to the Waifu constructor it not a valid mudae message&#34;)

        # Try to match footer:
        if not embed.footer.text:
            self.is_claimed = False
        else:
            match = re.search(r&#34;&#34;&#34;(?:Belongs\ to\ (.+?))? #Optionally capture owner
                                   (?:\ ~~\ )?               #Optionally match separator
                                   (?:                       #----&gt; Optionally capture image data
                                       (\d+?)                    #Capture first index
                                       \ /\ (\d+)                #Capture second index
                                       (?:\ \[(\d+?)\])?         #Optionally capture third index
                                   )?$                       #&lt;----- end of string
                                   &#34;&#34;&#34;, embed.footer.text, re.VERBOSE | re.DOTALL)
            if match.group(1):
                self.owner = message.guild.get_member_named(match.group(1))
                self.is_claimed = True
            else:
                self.is_claimed = False
            if match.group(2):
                self.image_index = int(match.group(2))
            if match.group(3):
                self.image_count = int(match.group(3))
            if match.group(4):
                self.image_extra = int(match.group(4))
            else:
                self.image_extra = 0

    async def fetch_extra(self):
        &#34;&#34;&#34;
        Fills the suitor and creator attributes.
        The suitor and creator attributes are by default empty and null respectively. To get the real values, this method must be called.
        The method will only work for waifus of type roll and only if the waifu was just rolled.
        &#34;&#34;&#34;

        state = 0
        async for message in self.message.channel.history(limit=10):
            if state == 0:
                if message.id == self.message.id:
                    state = 1
            elif state == 1:
                state += 1
                if message.author != self.mudae:
                    self.creator = message.author
                    break
                elif &#34;wished&#34; in message.content.lower():
                    self.suitors = message.mentions
            elif state == 5:
                break
            else:
                state += 1
                if message.author != self.mudae:
                    self.creator = message.author
                    break

        # await asyncio.sleep(1)
        # UNTESTED -------------------&gt;
        &#34;&#34;&#34;
        self.message = await self.message.channel.fetch_message(self.message_id)
        if self.is_claimed and self.is_roll:
            for react in self.message.reactions:
                name = react.emoji.name
                if &#34;kakera&#34; in name:
                    name = name.replace(&#34;kakera&#34;, &#34;&#34;)
                    if name == &#34;&#34;:
                        name = &#34;K&#34;
                    self.ka_react = name
                    break
        &#34;&#34;&#34;

    async def await_claim(self):
        &#34;&#34;&#34;
        Waits for a member to claim this waifu, then returns with that member.
        If the waifu has already been claimed, the owner is returned immediately.
        If the waifu doesn&#39;t have an owner, the function will wait for up to 60s for someone to claim.
        Returns none if after 60s no one has claimed.
        Returns
        -------
        Waifu
            The waifu has an owner or one is found.
        None
            No owner could be found, the waifu wasn&#39;t claimed within 60s.
        &#34;&#34;&#34;

        if self.is_claimed:
            return self.owner

        def check(message):
            return message.author == self.mudae and self.name in message.content and &#34;are now married&#34; in message.content.lower()

        try:
            message = await self.user.wait_for(&#34;message&#34;, timeout=60, check=check)
            user_name = message.content.split(&#34;**&#34;)[1]
            self.owner = message.guild.get_member_named(user_name)
            self.is_claimed = True
            return self.owner

        except asyncio.TimeoutError:
            return None


    def __str__(self):
        return self.name</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="main.Waifu.Type"><code class="name">var <span class="ident">Type</span></code></dt>
<dd>
<div class="desc"><p>Represents the different types of waifus.
Enums</p>
<hr>
<p>roll: 0
The waifu was rolled e.g. created with $w.
info: 1
The waifu came from the info command e.g. created with $im.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="main.Waifu.await_claim"><code class="name flex">
<span>async def <span class="ident">await_claim</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Waits for a member to claim this waifu, then returns with that member.
If the waifu has already been claimed, the owner is returned immediately.
If the waifu doesn't have an owner, the function will wait for up to 60s for someone to claim.
Returns none if after 60s no one has claimed.
Returns</p>
<hr>
<dl>
<dt><code><a title="main.Waifu" href="#main.Waifu">Waifu</a></code></dt>
<dd>The waifu has an owner or one is found.</dd>
<dt><code>None</code></dt>
<dd>No owner could be found, the waifu wasn't claimed within 60s.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def await_claim(self):
    &#34;&#34;&#34;
    Waits for a member to claim this waifu, then returns with that member.
    If the waifu has already been claimed, the owner is returned immediately.
    If the waifu doesn&#39;t have an owner, the function will wait for up to 60s for someone to claim.
    Returns none if after 60s no one has claimed.
    Returns
    -------
    Waifu
        The waifu has an owner or one is found.
    None
        No owner could be found, the waifu wasn&#39;t claimed within 60s.
    &#34;&#34;&#34;

    if self.is_claimed:
        return self.owner

    def check(message):
        return message.author == self.mudae and self.name in message.content and &#34;are now married&#34; in message.content.lower()

    try:
        message = await self.user.wait_for(&#34;message&#34;, timeout=60, check=check)
        user_name = message.content.split(&#34;**&#34;)[1]
        self.owner = message.guild.get_member_named(user_name)
        self.is_claimed = True
        return self.owner

    except asyncio.TimeoutError:
        return None</code></pre>
</details>
</dd>
<dt id="main.Waifu.fetch_extra"><code class="name flex">
<span>async def <span class="ident">fetch_extra</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Fills the suitor and creator attributes.
The suitor and creator attributes are by default empty and null respectively. To get the real values, this method must be called.
The method will only work for waifus of type roll and only if the waifu was just rolled.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def fetch_extra(self):
    &#34;&#34;&#34;
    Fills the suitor and creator attributes.
    The suitor and creator attributes are by default empty and null respectively. To get the real values, this method must be called.
    The method will only work for waifus of type roll and only if the waifu was just rolled.
    &#34;&#34;&#34;

    state = 0
    async for message in self.message.channel.history(limit=10):
        if state == 0:
            if message.id == self.message.id:
                state = 1
        elif state == 1:
            state += 1
            if message.author != self.mudae:
                self.creator = message.author
                break
            elif &#34;wished&#34; in message.content.lower():
                self.suitors = message.mentions
        elif state == 5:
            break
        else:
            state += 1
            if message.author != self.mudae:
                self.creator = message.author
                break

    # await asyncio.sleep(1)
    # UNTESTED -------------------&gt;
    &#34;&#34;&#34;
    self.message = await self.message.channel.fetch_message(self.message_id)
    if self.is_claimed and self.is_roll:
        for react in self.message.reactions:
            name = react.emoji.name
            if &#34;kakera&#34; in name:
                name = name.replace(&#34;kakera&#34;, &#34;&#34;)
                if name == &#34;&#34;:
                    name = &#34;K&#34;
                self.ka_react = name
                break
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="main.get_timing" href="#main.get_timing">get_timing</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="main.Mudae" href="#main.Mudae">Mudae</a></code></h4>
<ul class="two-column">
<li><code><a title="main.Mudae.from_wish" href="#main.Mudae.from_wish">from_wish</a></code></li>
<li><code><a title="main.Mudae.until_claim" href="#main.Mudae.until_claim">until_claim</a></code></li>
<li><code><a title="main.Mudae.until_roll" href="#main.Mudae.until_roll">until_roll</a></code></li>
<li><code><a title="main.Mudae.waifu_from" href="#main.Mudae.waifu_from">waifu_from</a></code></li>
<li><code><a title="main.Mudae.wait_claim" href="#main.Mudae.wait_claim">wait_claim</a></code></li>
<li><code><a title="main.Mudae.wait_roll" href="#main.Mudae.wait_roll">wait_roll</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="main.Waifu" href="#main.Waifu">Waifu</a></code></h4>
<ul class="">
<li><code><a title="main.Waifu.Type" href="#main.Waifu.Type">Type</a></code></li>
<li><code><a title="main.Waifu.await_claim" href="#main.Waifu.await_claim">await_claim</a></code></li>
<li><code><a title="main.Waifu.fetch_extra" href="#main.Waifu.fetch_extra">fetch_extra</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>